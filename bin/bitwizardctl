#!/usr/bin/env ruby

require 'bitwizard'
require 'optparse'

class BasicLogger
	def debug(string)
		puts string
	end
end

Options = {
	:bus => :spi,
	:verbose => false,
	:scan => true
}

class BitWizardCTL

	DetailedHelp = {
		:scan => { :text => "Scans for available boards" },
		:list => { :text => "Lists all the found boards" },
		:eeprom => { :args => "[addrs]", :text => "Read the eeprom from the specified address(es), or all found boards if none given" },
		:exit => { :text => "Exits the program" },
		:help => { :text => "Lists all the valid commands, or detailed help for a given command" }
	}

	def initialize(args)
		@defaultlogger = BasicLogger.new if Options[:verbose]
		@boards = {}
		@boards = cmd_scan if Options[:scan]

		puts "", "BitWizardCTL "

		print "> "
		STDIN.each_line do |line|
			data = line.split
			command = data[0]
			arguments = data[1] if data.count > 1
			arguments = data[1..-1] if data.count > 2

			if respond_to? "cmd_#{command}".to_sym then
				send "cmd_#{command}".to_sym, arguments
			else
				puts "Unknown command '#{command}', try 'help' for a list of valid ones"
			end

			print "> "
		end
	end

	def cmd_help(*)
		longestcmd = 0
		DetailedHelp.each do |cmd,data|
			curlen = cmd.length
			curlen += data[:args].length if data.has_key? :args
			longestcmd = curlen if curlen > longestcmd end

		puts "Available commands:"
		DetailedHelp.each do |cmd, help|
			puts "  #{cmd} #{help[:args] if help.has_key? :args} #{" " * (longestcmd - cmd.length - (help[:args] and help[:args].length or 0))}#{help[:text]}"
		end
	end

	def cmd_exit(*)
		exit
	end

	def cmd_scan(*)
		puts "Scanning for boards..."

		(0..0xff).step(2) do |address|
			begin
				temp = BitWizard::Board.new :address => address, :bus => Options[:bus]

				temp = temp.known_board[:constructor].call(:address => address) if temp.valid?
				temp.logger = @defaultlogger if Options[:verbose]
				@boards[temp.address] = temp
				puts "0x#{address.to_s(16)}: #{temp.type} (#{temp.version})" if temp.valid? 
			rescue
			end
		end
	end

	def cmd_list(*)
		puts "Boards:"

		@boards.each do |board|
			puts "0x#{board.address}: #{board.type} (#{board.version})"
		end
	end

	def cmd_eeprom(*args)
		if args.count == 0 or args.count == 1 and args[0].is_a? NilClass then
			@boards.each do |board|
				puts "0x#{board.address.to_s(16)}: #{board.read(0x2, 4).pack("l>")}"
			end
		else
			args.each do |addr|
				next unless /^(0x[0-9]{1,2}|[0-9]{1,3})$/ =~ addr
				addr = eval "#{addr}"
				next unless (0..255).include? addr
				puts "0x#{addr.to_i.to_s(16)}: #{BitWizard::Board.new(:address => addr.to_i, :skip_check => true).read(0x2, 4).pack("l>")}"
			end
		end
	end

end

OptionParser.new do |opts|
	opts.banner = "Usage: #{File.basename($0)} [options] [command [arguments]]"
	opts.separator ""
	opts.separator "Options:"

	opts.on("-i", "--i2c", "Use I2C instead of SPI") do |i|
		Options[:bus] = :i2c
	end

	opts.on("-s", "--skip", "Skip the scan on start") do
		Options[:scan] = false
	end

	opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
		Options[:verbose] = v
	end

	opts.on("-h", "--help", "Shows this text") do
		puts opts
		exit
	end

	opts.separator ""
	opts.separator "Commands:"

	BitWizardCTL::DetailedHelp.each do |cmd, help|
		opts.separator "  #{cmd}"
		opts.separator "    #{help}"

	end
end.parse!

BitWizardCTL.new ARGV
puts