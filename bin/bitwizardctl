#!/usr/bin/env ruby

require 'bitwizard'
require 'optparse'

class BasicLogger
	def debug(string)
		puts string
	end
end

Options = {
	:bus => :spi,
	:verbose => false,
	:scan => true
}

class BitWizardCTL

	DetailedHelp = {
		:scan => { :text => "Scans for available boards" },
		:list => { :text => "Lists all the found boards" },
		:eeprom => { :args => "[addrs]", :text => "Read the eeprom from the specified address(es), or all found boards if none given" },
		:exit => { :text => "Exits the program" },
		:help => { :text => "Lists all the valid commands, or detailed help for a given command" },
		:pwm => { :args => "<addr> <port> [value]", :text => "Get/Set the PWM value for a certain port on a board" }
	}

	def initialize(args)
		@defaultlogger = BasicLogger.new if Options[:verbose]
		@boards = {}
		cmd_scan if Options[:scan]

		puts "", "BitWizardCTL "

		print "> "
		STDIN.each_line do |line|
			data = line.split
			command = data.shift
			arguments = data[0] if data.count == 1
			arguments = data[0..-1] if data.count > 1

			if respond_to? "cmd_#{command}".to_sym then
				begin
					send("cmd_#{command}".to_sym, *arguments)
				rescue ArgumentError => ex
					puts "  \e[31m#{ex}\e[0m"
					if Options[:verbose] then
						ex.backtrace.each do |line|
							puts "    #{line}"
						end
					end
				end
			else
				puts "Unknown command '#{command}', try 'help' for a list of valid ones"
			end

			print "> "
		end
	end

	def cmd_help(*)
		longestcmd = 0
		DetailedHelp.each do |cmd,data|
			curlen = cmd.length
			curlen += data[:args].length if data.has_key? :args
			longestcmd = curlen if curlen > longestcmd
		end

		puts "Available commands:"
		DetailedHelp.each do |cmd, help|
			puts "  #{cmd} #{help[:args] if help.has_key? :args} #{" " * (longestcmd - cmd.length - (help[:args] and help[:args].length or 0))}#{help[:text]}"
		end
	end

	def cmd_exit(*)
		exit
	end

	def cmd_scan(*)
		puts "Scanning for boards..."

		@boards = { }
		(0..0xff).step(2) do |address|
			begin
				temp = BitWizard::Board.detect :address => address, :bus => Options[:bus], :logger => (@defaultlogger if Options[:verbose])
				next unless temp.valid?

				@boards[temp.address] = temp
				puts "0x#{address.to_s(16)}: #{temp.type} (#{temp.version})"
			rescue ArgumentError
			end
		end
	end

	def cmd_list(*)
		puts "Boards:"

		@boards.each do |addr, board|
			puts "0x#{board.address.to_s(16)}: #{board.type} (#{board.version})"
		end
	end

	def cmd_eeprom(*args)
		if args.count == 0 then
			@boards.each do |addr, board|
				puts "0x#{board.address.to_s(16)}: #{board.read(0x2, 4).pack("l>")}"
			end
		else
			args.each do |addr|
				addr = eval "#{addr}" if /^0x[0-9a-fA-F]{1,2}$/ =~ addr
				p addr
				next unless (0..255).include? addr
				puts "0x#{addr.to_i.to_s(16)}: #{BitWizard::Board.new(:address => addr.to_i, :skip_check => true, :bus => Options[:bus]).read(0x2, 4).pack("l>")}"
			end
		end
	end

	def cmd_pwm(*args)
		raise ArgumentError.new "Wrong number of arguments (#{args.count} for 2-3)" unless (2..3).include? args.count
		addr, port, value = *args if args.count == 3
		value = value.to_i if value
		addr, port = *args if args.count == 2
		port = port.to_i

		addr = eval "#{addr}" if /^0x[0-9a-fA-F]{1,2}$/ =~ addr
		raise ArgumentError.new "Value must be between 0 and 100" if value and not (0..100).include? value

		board = @boards[addr] if @boards.has_key? addr
		unless board then
			board = BitWizard::Board.detect :address => addr, :bus => Options[:bus]
			@boards[addr] = board if board.valid?
		end

		raise ArgumentError.new "No valid board on the given address" unless board.valid?
		raise ArgumentError.new "Board doesn't support PWM actions" unless board.known_board[:features].include? :pwm

		board[port] = (value/100.0 * 255).floor if value
		puts "0x#{addr.to_s(16)}[#{port}] = #{(board[port] / 255.0) * 100}%"
	end

end

OptionParser.new do |opts|
	opts.banner = "Usage: #{File.basename($0)} [options] [command [arguments]]"
	opts.separator ""
	opts.separator "Options:"

	opts.on("-i", "--i2c", "Use I2C instead of SPI") do |i|
		Options[:bus] = :i2c
	end

	opts.on("-s", "--skip", "Skip the scan on start") do
		Options[:scan] = false
	end

	opts.on("-v", "--[no-]verbose", "Run verbosely") do |v|
		Options[:verbose] = v
	end

	opts.on("-h", "--help", "Shows this text") do
		puts opts
		exit
	end

	opts.separator ""
	opts.separator "Commands:"

	BitWizardCTL::DetailedHelp.each do |cmd, help|
		opts.separator "  #{cmd}"
		opts.separator "    #{help}"

	end
end.parse!

BitWizardCTL.new ARGV
puts